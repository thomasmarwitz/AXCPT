<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AXCPT</title>
    <script src="jspsych-6.2.0/jspsych.js"></script>
    <!-- CSS -->
    <link href="jspsych-6.2.0/css/jspsych.css" rel="stylesheet" type="text/css">
    <!-- PLugins -->
    <script src="jspsych-6.2.0/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="jspsych-6.2.0/plugins/jspsych-instructions.js"></script>
    <script src="jspsych-6.2.0/plugins/jspsych-fullscreen.js"></script>
    <!--Include jQuery library-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <!--load custom helper scripts-->
    <script src="helper.js"></script>
    <script src="csv-formatter.js"></script> <!--JSON2CSV-->
    <!--CSS-->
    <link href="styles.css" rel="stylesheet" type="text/css">

</head>
<body id="experiment-body"></body>
<script>

    // Fullscreen, hidecursor

    const SUBJECT_ID = jsPsych.randomization.randomID(16).toUpperCase()
    const AMOUNT_EXPERIMENT_TRIALS = 10 // Cue + Probe is ONE trial
    const AMOUNT_PRACTICE_TRIALS = 10
    const ALPHABET = [...'ABCDEFGHIJKLMNOPQRSTUVWXYZ']
    const PHP_SCRIPT_FILE = 'write_data.php' // SAVING DATA PHP-SCRIPT
    const CUE = "A"
    const TARGET_KEY = "f"
    const PROBE = "X"
    const NON_TARGET_KEY = "j"
    const EXCLUDED_CUE = [CUE, PROBE, "K", "Y"]
    const EXCLUDED_PROBE = [CUE, PROBE, "K", "Y"] // alles, außer Y und K, A und X
    const NON_CUE = ALPHABET.filter((c) => !EXCLUDED_CUE.includes(c)) 
    const NON_PROBE = ALPHABET.filter((c) => !EXCLUDED_PROBE.includes(c)) 
    const SHORT_CONDITION_TIME = 1000
    const LONG_CONDITION_TIME = 5000
    const MAX_ANSWER_TIME = 1500
    const STIMULUS_PRESENTATION_TIME = 500
    const DISTRACTION_INTERFERENCE = false // this is not yet implemented
    const DELAY = SHORT_CONDITION_TIME // in seconds, long delay: 5(!)-10s
    const CUE_PROBE_FONTSIZE = "60px"
    const PENALITY_FONTSIZE = "60px"
    const FEEDBACK_FONTSIZE = "60px"
    const VISUAL_FEEDBACK_COLOR = "#BFBFBF"
    const BACKGROUND_COLOR = "#686868"
    const NO_ANSWER_GIVEN = "-"
    const TRIALS_PER_BLOCK = 10
    const TRIALS_PER_PRACTICE = 10
    const EXPERIMENT_STRUCTURE = {"A": SHORT_CONDITION_TIME, "B": LONG_CONDITION_TIME} // delays given
    const FULLSCREEN_START_MESSAGE = (
        `
        <p style="font-size:36px;"><strong>Herzlich willkommen zum AXCPT-Experiment</strong></p>
        <p style="font-size:26px; line-height: 34px;">Drücken Sie auf "Weiter", um in den Vollbildmodus<br>
            zu wechseln und mit dem Experiment zu beginnen.</p>
        `
    )
    const INSTRUCTION_SLIDE = (
        `
        Im Folgenden werden Ihnen Buchstaben präsentiert.<br>
        Wenn auf ein <strong>A</strong> als nächster Buchstabe ein <strong>X</strong> folgt,<br>
        drücken Sie bitte die Taste <strong>f</strong>, ansonsten die Tasten <strong>j</strong>.<br>
        Sie haben 1,5 Sekunden Zeit für Ihre Antwort.
        `
    )
    // both are incremented before storing => starting at 1
    let trialIndex = 0 // continous
    let trialBlock = 0 // starts after practice at 1
    let lastTrialSet = "" // used to track when block number has changed

    const INTERTRIAL_DELAY = DELAY == SHORT_CONDITION_TIME ? LONG_CONDITION_TIME : SHORT_CONDITION_TIME // varies inversly

    // UTILITY FUNCS

    function getRandomElement(array) {
        return jsPsych.randomization.sampleWithoutReplacement(array, 1)[0]
    }

    function changeBackgroundColor(colorString) {
        $("#jspsych-target").css("background-color", colorString)
        $("#experiment-body").css("background-color", colorString)
    }

    function generateTrialList(n) {
        const AMOUNT_TARGET = n * 0.7               // AX
        const AMOUNT_NON_CUE_PROBE = n * 0.1        // BX
        const AMOUNT_CUE_NON_PROBE = n * 0.1        // AY
        const AMOUNT_NON_CUE_NON_PROBE = n * 0.1    // BY

        const STANDARD_ARRAY = jsPsych.randomization.repeat(
            ["AX", "BX", "AY", "BY"], 
            [AMOUNT_TARGET, AMOUNT_NON_CUE_PROBE, AMOUNT_NON_CUE_PROBE, AMOUNT_NON_CUE_NON_PROBE], 
            false) // generate the conditions with standard values

        return STANDARD_ARRAY.map((condition) => {
            const RANDOM_NON_CUE =      getRandomElement(NON_CUE)
            const RANDOM_NON_PROBE =    getRandomElement(NON_PROBE)
            
            return { // turn standard array with mapping into destandardized array (random non cues/probes)
                    cue: condition[0]
                        .replace("B", RANDOM_NON_CUE),
                    probe: condition[1]
                        .replace("Y", RANDOM_NON_PROBE),
                    condition,
                    isTarget: condition === "AX",
                }  
        })
    }

    function generateTimelineVariables(n, isPractice=false, currentSet=1) {
        if (n % 10 != 0) {
            console.log("Warning, not a multiple of ten, filling up to multiple of ten")
            n += 10 - (n % 10) // fill up to ten
        }
        const TRIAL_LIST = generateTrialList(n)
        return TRIAL_LIST.map((condition) => {
            return {
                cue: condition.cue,
                probe: condition.probe,
                condition: condition.condition,
                isTarget: condition.isTarget,
                isPractice,
                currentSet: isPractice ? "-" : currentSet, // keep track of current block
            }
        })
    }
    
    function answeredLastTrial() {
        const LAST_DATA = jsPsych.data.get().last().values()[0]
        return LAST_DATA.rt != null
    }

    function answeredLastTrialCorrect() {
        return jsPsych.data.get().filter({relevant: true}).last(1).values()[0].correct
    }

    function getDelayTrial(delayTime) {
        return {
            type: "html-keyboard-response",
            stimulus: "",
            choices: jsPsych.NO_KEYS,
            trial_duration: delayTime,
        }
    }

    // DATA SAVING FUNCS

    function processData(data) {

        const formattedData = []

        for (let trialData of data) {
            formattedData.push({
                subcode: SUBJECT_ID,
                time: trialData.time,
                timeelap: trialData.time_elapsed,
                phase: trialData.phase,
                trialNr: trialData.trialIndex,
                trialBlock: trialData.trialBlock,
                isTarget: trialData.isTarget,
                condition: trialData.condition,
                cue: trialData.cue,
                probe: trialData.probe,
                answer: trialData.answer,
                correct: trialData.correct,
                rt: roundTo(trialData.rt, 2),
            })
        }

        return formattedData
    }

    function saveData(name, data){
        let xhr = new XMLHttpRequest();
        xhr.open('POST', PHP_SCRIPT_FILE); // PHP_SCRIPT_FILE
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(JSON.stringify({filename: name, filedata: data}));
        console.log("saved data to: data/" + name);
        return true;
    }

    const finishUp = () => {
        const fileName = `AXCPT_${getDate("")}_${getTime("")}_${SUBJECT_ID}`
        const relevantData = jsPsych.data.get().filter({relevant: true}).values() 
        saveData(fileName, JSON2CSV(processData(relevantData)))
    }


    // TRIALS

    const ENTER_FULLSCREEN = {
        type: "fullscreen",
        message: FULLSCREEN_START_MESSAGE,
        button_label: "Weiter",
        fullscreen_mode: true,
        delay_after: 0,
    }


    const EXIT_FULLSCREEN = {
        type: "fullscreen",
        fullscreen_mode: false, // false will cause to leave fullscreen
        delay_after: 0,
        on_start: () => {
            showCursor()
        },
    }


    const INSTRUCTIONS = {
        type: "instructions",
        pages: [
            INSTRUCTION_SLIDE,
            "Drücken Sie auf \"Weiter\", um anhand einiger Beispiele zu üben."
        ],
        show_clickable_nav: true,
        button_label_next: "Weiter",
        allow_backward: false,
        on_finish: () => {
            hideCursor()
        }
    }

    
    const AFTER_PRACTICE = {
        type: "instructions",
        pages: [
            "Die Übung ist nun vorbei.<br>Wenn Sie eine Eingabe getätigt haben,<br>erhälten Sie visuelles Feedback in Form eines Flackerns.",
            "Drücken Sie auf \"Weiter\", um mit dem Experiment zu beginnen.",
        ],
        show_clickable_nav: true,
        button_label_next: "Weiter",
        allow_backward: false,
        on_start: () => {
            showCursor()
        },
        on_finish: () => {
            hideCursor()
        }
    }


    const CUE_PRESENTATION = {
        type: "html-keyboard-response",
        stimulus: () => {
            return `<span style="font-size:${CUE_PROBE_FONTSIZE}">${jsPsych.timelineVariable("cue", true)}</span>`
        },
        trial_duration: STIMULUS_PRESENTATION_TIME,
        choices: jsPsych.NO_KEYS,
    }


    const PROBE_PRESENTATION = {
        type: "html-keyboard-response",
        stimulus: () => {
            return `<span style="font-size:${CUE_PROBE_FONTSIZE}">${jsPsych.timelineVariable("probe", true)}</span>`
        },
        trial_duration: MAX_ANSWER_TIME, 
        choices: [TARGET_KEY, NON_TARGET_KEY],
        on_finish: (data) => {
            data.phase = jsPsych.timelineVariable("isPractice", true) ? "practice" : "experiment"
            data.time = getTime()
            data.trialIndex = ++trialIndex // count continuously
            
            // reset trial Block?
            const currentTrialSet = jsPsych.timelineVariable("currentSet", true)
            if (currentTrialSet !== lastTrialSet) {
                trialBlock = 0
                lastTrialSet = currentTrialSet // update
            }
            data.trialBlock = ++trialBlock // count each block, reset in AFTER_PRACTICE
            data.trialSet = currentTrialSet
            data.cue = jsPsych.timelineVariable("cue", true)
            data.probe = jsPsych.timelineVariable("probe", true)
            data.condition = jsPsych.timelineVariable("condition", true)
            data.isTarget = jsPsych.timelineVariable("isTarget", true)
            if (data.rt !== null) {
                const answer = jsPsych.pluginAPI.convertKeyCodeToKeyCharacter(data.key_press)
                data.answer = answer
                const correctAnswer = data.isTarget ? TARGET_KEY : NON_TARGET_KEY
                data.correct = answer === correctAnswer
            } else {
                // TODO: should we do this? data.rt = MAX_ANSWER_TIME // time took to answer
                data.answer = NO_ANSWER_GIVEN
                data.correct = NO_ANSWER_GIVEN
            }
            data.relevant = true // to filter for these trials
        }
    }


    const PENALITY_AND_VISUAL = {
        type: "html-keyboard-response",
        stimulus: () => {
            return answeredLastTrial() ? "" : `<span style="font-size:${PENALITY_FONTSIZE}">ZU LANGSAM!</span>`
        },
        on_start: (data) => {
            const hasAnswered = answeredLastTrial()
            data.trial_duration = hasAnswered ? 10 : 2000
            if (hasAnswered) {
                changeBackgroundColor(VISUAL_FEEDBACK_COLOR)
            }
        },
        trial_duration: 1,
        choices: jsPsych.NO_KEYS,
        on_finish: () => {
            changeBackgroundColor(BACKGROUND_COLOR)
        }
    }


    const FEEDBACK = { // used for practicing
        type: "html-keyboard-response",
        stimulus: () => {
            if (!answeredLastTrial()) {
                return `<span style="font-size:${PENALITY_FONTSIZE}">ZU LANGSAM!</span>`
            } else if (answeredLastTrialCorrect()) {
                return `<span style="font-size:${PENALITY_FONTSIZE};color: lightgreen">RICHTIG</span>`
            } else {
                return `<span style="font-size:${PENALITY_FONTSIZE};color: red">FALSCH</span>`
            }
        },
        trial_duration: 1000,
        choices: jsPsych.NO_KEYS,
    }


    const END = {
        type: "html-keyboard-response",
        stimulus: "Das Experiment ist zu Ende, die Daten wurden gespeichert!",
        on_start: () => {
            finishUp() // save data
        }
    }


    // STRUCTURE

    function generateFullExperimentTrials(trialAmount, delayCondition=SHORT_CONDITION_TIME, isPractice=false) {
        const INTERTRIAL_CONDITION = delayCondition === SHORT_CONDITION_TIME ? LONG_CONDITION_TIME : SHORT_CONDITION_TIME
        const AFTER_PROBE_TRIAL = isPractice ? FEEDBACK : PENALITY_AND_VISUAL
        return {
            timeline: [CUE_PRESENTATION, getDelayTrial(delayCondition), PROBE_PRESENTATION, AFTER_PROBE_TRIAL, getDelayTrial(INTERTRIAL_CONDITION)],
            timeline_variables: generateTimelineVariables(trialAmount, isPractice=isPractice),
        }
    }

    // generate trials according to structure of experiment
    const A_1 = generateFullExperimentTrials(TRIALS_PER_BLOCK, EXPERIMENT_STRUCTURE.A, isPractice=false)
    const A_2 = generateFullExperimentTrials(TRIALS_PER_BLOCK, EXPERIMENT_STRUCTURE.A, isPractice=false)
    const B_1 = generateFullExperimentTrials(TRIALS_PER_BLOCK, EXPERIMENT_STRUCTURE.B, isPractice=false)
    const B_2 = generateFullExperimentTrials(TRIALS_PER_BLOCK, EXPERIMENT_STRUCTURE.B, isPractice=false)

    // insert: 2 practices, pauses (updates)
    const A_PRACTICE = generateFullExperimentTrials(TRIALS_PER_PRACTICE, EXPERIMENT_STRUCTURE.A, isPractice=true)
    const B_PRACTICE = generateFullExperimentTrials(TRIALS_PER_PRACTICE, EXPERIMENT_STRUCTURE.B, isPractice=true)

    function getPauseTrial(completedParts) {
        return {
            type: "html-keyboard-response",
            stimulus: `<progress value="${completedParts}" max="4">70 %</progress><br><br>Wie wäre es mit einer kleinen Pause?<br>Drücken Sie die <em>Leertaste</em>, um fortzufahren.`,
            choices: ["space"],
        }
    }

    // placeholder
    const INSTRUCTIONS_A = {
        type: "html-keyboard-response",
        stimulus: "Instructions A",
    }
    
    const AFTER_PRACTICE_A = {
        type: "html-keyboard-response",
        stimulus: "Nun geht es los mit den echten Trials",
    }
    
    const INSTRUCTIONS_B = {
        type: "html-keyboard-response",
        stimulus: "Instructions A",
    }
    
    const AFTER_PRACTICE_B = {
        type: "html-keyboard-response",
        stimulus: "Nun geht es los mit den echten Trials",
    }

    const TIMELINE_ALL_TRIALS = [INSTRUCTIONS_A, A_PRACTICE, AFTER_PRACTICE_A, A_1, getPauseTrial(1), A_2, getPauseTrial(2), INSTRUCTIONS_B, B_PRACTICE, AFTER_PRACTICE_B, B_1, getPauseTrial(3), B_2]

    /*
    const PRACTICE_TRIALS = {
        timeline: [CUE_PRESENTATION, getDelayTrial(DELAY), PROBE_PRESENTATION, FEEDBACK, getDelayTrial(INTERTRIAL_DELAY)],
        timeline_variables: generateTimelineVariables(AMOUNT_PRACTICE_TRIALS, isPractice=true),
    }
    
    const EXP_TRIALS = {
        timeline: [CUE_PRESENTATION, getDelayTrial(DELAY), PROBE_PRESENTATION, PENALITY_AND_VISUAL, getDelayTrial(INTERTRIAL_DELAY)],
        timeline_variables: generateTimelineVariables(AMOUNT_EXPERIMENT_TRIALS, isPractice=false),
    }

    jsPsych.init({
        timeline: [ENTER_FULLSCREEN, INSTRUCTIONS, PRACTICE_TRIALS, AFTER_PRACTICE, EXP_TRIALS, EXIT_FULLSCREEN, END],
    })
    */

    jsPsych.init({
        timeline: [ENTER_FULLSCREEN, INSTRUCTIONS, ...TIMELINE_ALL_TRIALS, EXIT_FULLSCREEN, END],
    })
</script>
</html>